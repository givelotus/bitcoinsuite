#![allow(unused_imports, dead_code, clippy::all)]
// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod nng_interface {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RPC_REQUEST: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RPC_REQUEST: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RPC_REQUEST: [RpcRequest; 6] = [
  RpcRequest::NONE,
  RpcRequest::GetBlockRequest,
  RpcRequest::GetBlockRangeRequest,
  RpcRequest::GetBlockSliceRequest,
  RpcRequest::GetUndoSliceRequest,
  RpcRequest::GetMempoolRequest,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RpcRequest(pub u8);
#[allow(non_upper_case_globals)]
impl RpcRequest {
  pub const NONE: Self = Self(0);
  pub const GetBlockRequest: Self = Self(1);
  pub const GetBlockRangeRequest: Self = Self(2);
  pub const GetBlockSliceRequest: Self = Self(3);
  pub const GetUndoSliceRequest: Self = Self(4);
  pub const GetMempoolRequest: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::GetBlockRequest,
    Self::GetBlockRangeRequest,
    Self::GetBlockSliceRequest,
    Self::GetUndoSliceRequest,
    Self::GetMempoolRequest,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::GetBlockRequest => Some("GetBlockRequest"),
      Self::GetBlockRangeRequest => Some("GetBlockRangeRequest"),
      Self::GetBlockSliceRequest => Some("GetBlockSliceRequest"),
      Self::GetUndoSliceRequest => Some("GetUndoSliceRequest"),
      Self::GetMempoolRequest => Some("GetMempoolRequest"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RpcRequest {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RpcRequest {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for RpcRequest {
    type Output = RpcRequest;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for RpcRequest {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RpcRequest {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RpcRequest {}
pub struct RpcRequestUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BLOCK_IDENTIFIER: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BLOCK_IDENTIFIER: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BLOCK_IDENTIFIER: [BlockIdentifier; 3] = [
  BlockIdentifier::NONE,
  BlockIdentifier::Height,
  BlockIdentifier::Hash,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BlockIdentifier(pub u8);
#[allow(non_upper_case_globals)]
impl BlockIdentifier {
  pub const NONE: Self = Self(0);
  pub const Height: Self = Self(1);
  pub const Hash: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Height,
    Self::Hash,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Height => Some("Height"),
      Self::Hash => Some("Hash"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BlockIdentifier {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BlockIdentifier {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for BlockIdentifier {
    type Output = BlockIdentifier;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for BlockIdentifier {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BlockIdentifier {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BlockIdentifier {}
pub struct BlockIdentifierUnionTableOffset {}

// struct Hash, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Hash(pub [u8; 32]);
impl Default for Hash { 
  fn default() -> Self { 
    Self([0; 32])
  }
}
impl core::fmt::Debug for Hash {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Hash")
      .field("data", &self.data())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Hash {}
impl flatbuffers::SafeSliceAccess for Hash {}
impl<'a> flatbuffers::Follow<'a> for Hash {
  type Inner = &'a Hash;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Hash>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Hash {
  type Inner = &'a Hash;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Hash>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Hash {
    type Output = Hash;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::core::slice::from_raw_parts(self as *const Hash as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Hash {
    type Output = Hash;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::core::slice::from_raw_parts(*self as *const Hash as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Hash {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Hash {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    data: &[u8; 32],
  ) -> Self {
    let mut s = Self([0; 32]);
    s.set_data(data);
    s
  }

  pub fn data(&'a self) -> flatbuffers::Array<'a, u8, 32> {
    flatbuffers::Array::follow(&self.0, 0)
  }

  pub fn set_data(&mut self, items: &[u8; 32]) {
    flatbuffers::emplace_scalar_array(&mut self.0, 0, items);
  }

}

pub enum RpcResultOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RpcResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RpcResult<'a> {
  type Inner = RpcResult<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> RpcResult<'a> {
  pub const VT_IS_SUCCESS: flatbuffers::VOffsetT = 4;
  pub const VT_ERROR_CODE: flatbuffers::VOffsetT = 6;
  pub const VT_ERROR_MSG: flatbuffers::VOffsetT = 8;
  pub const VT_DATA: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RpcResult { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RpcResultArgs<'args>
  ) -> flatbuffers::WIPOffset<RpcResult<'bldr>> {
    let mut builder = RpcResultBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.error_msg { builder.add_error_msg(x); }
    builder.add_error_code(args.error_code);
    builder.add_is_success(args.is_success);
    builder.finish()
  }


  #[inline]
  pub fn is_success(&self) -> bool {
    self._tab.get::<bool>(RpcResult::VT_IS_SUCCESS, Some(false)).unwrap()
  }
  #[inline]
  pub fn error_code(&self) -> i32 {
    self._tab.get::<i32>(RpcResult::VT_ERROR_CODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn error_msg(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RpcResult::VT_ERROR_MSG, None)
  }
  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RpcResult::VT_DATA, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for RpcResult<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("is_success", Self::VT_IS_SUCCESS, false)?
     .visit_field::<i32>("error_code", Self::VT_ERROR_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("error_msg", Self::VT_ERROR_MSG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct RpcResultArgs<'a> {
    pub is_success: bool,
    pub error_code: i32,
    pub error_msg: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RpcResultArgs<'a> {
  #[inline]
  fn default() -> Self {
    RpcResultArgs {
      is_success: false,
      error_code: 0,
      error_msg: None,
      data: None,
    }
  }
}

pub struct RpcResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RpcResultBuilder<'a, 'b> {
  #[inline]
  pub fn add_is_success(&mut self, is_success: bool) {
    self.fbb_.push_slot::<bool>(RpcResult::VT_IS_SUCCESS, is_success, false);
  }
  #[inline]
  pub fn add_error_code(&mut self, error_code: i32) {
    self.fbb_.push_slot::<i32>(RpcResult::VT_ERROR_CODE, error_code, 0);
  }
  #[inline]
  pub fn add_error_msg(&mut self, error_msg: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RpcResult::VT_ERROR_MSG, error_msg);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RpcResult::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RpcResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RpcResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RpcResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RpcResult<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RpcResult");
      ds.field("is_success", &self.is_success());
      ds.field("error_code", &self.error_code());
      ds.field("error_msg", &self.error_msg());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum RpcCallOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RpcCall<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RpcCall<'a> {
  type Inner = RpcCall<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> RpcCall<'a> {
  pub const VT_RPC_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_RPC: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RpcCall { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RpcCallArgs
  ) -> flatbuffers::WIPOffset<RpcCall<'bldr>> {
    let mut builder = RpcCallBuilder::new(_fbb);
    if let Some(x) = args.rpc { builder.add_rpc(x); }
    builder.add_rpc_type(args.rpc_type);
    builder.finish()
  }


  #[inline]
  pub fn rpc_type(&self) -> RpcRequest {
    self._tab.get::<RpcRequest>(RpcCall::VT_RPC_TYPE, Some(RpcRequest::NONE)).unwrap()
  }
  #[inline]
  pub fn rpc(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(RpcCall::VT_RPC, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn rpc_as_get_block_request(&self) -> Option<GetBlockRequest<'a>> {
    if self.rpc_type() == RpcRequest::GetBlockRequest {
      self.rpc().map(GetBlockRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn rpc_as_get_block_range_request(&self) -> Option<GetBlockRangeRequest<'a>> {
    if self.rpc_type() == RpcRequest::GetBlockRangeRequest {
      self.rpc().map(GetBlockRangeRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn rpc_as_get_block_slice_request(&self) -> Option<GetBlockSliceRequest<'a>> {
    if self.rpc_type() == RpcRequest::GetBlockSliceRequest {
      self.rpc().map(GetBlockSliceRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn rpc_as_get_undo_slice_request(&self) -> Option<GetUndoSliceRequest<'a>> {
    if self.rpc_type() == RpcRequest::GetUndoSliceRequest {
      self.rpc().map(GetUndoSliceRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn rpc_as_get_mempool_request(&self) -> Option<GetMempoolRequest<'a>> {
    if self.rpc_type() == RpcRequest::GetMempoolRequest {
      self.rpc().map(GetMempoolRequest::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for RpcCall<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<RpcRequest, _>("rpc_type", Self::VT_RPC_TYPE, "rpc", Self::VT_RPC, false, |key, v, pos| {
        match key {
          RpcRequest::GetBlockRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetBlockRequest>>("RpcRequest::GetBlockRequest", pos),
          RpcRequest::GetBlockRangeRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetBlockRangeRequest>>("RpcRequest::GetBlockRangeRequest", pos),
          RpcRequest::GetBlockSliceRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetBlockSliceRequest>>("RpcRequest::GetBlockSliceRequest", pos),
          RpcRequest::GetUndoSliceRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetUndoSliceRequest>>("RpcRequest::GetUndoSliceRequest", pos),
          RpcRequest::GetMempoolRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetMempoolRequest>>("RpcRequest::GetMempoolRequest", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct RpcCallArgs {
    pub rpc_type: RpcRequest,
    pub rpc: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RpcCallArgs {
  #[inline]
  fn default() -> Self {
    RpcCallArgs {
      rpc_type: RpcRequest::NONE,
      rpc: None,
    }
  }
}

pub struct RpcCallBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RpcCallBuilder<'a, 'b> {
  #[inline]
  pub fn add_rpc_type(&mut self, rpc_type: RpcRequest) {
    self.fbb_.push_slot::<RpcRequest>(RpcCall::VT_RPC_TYPE, rpc_type, RpcRequest::NONE);
  }
  #[inline]
  pub fn add_rpc(&mut self, rpc: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RpcCall::VT_RPC, rpc);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RpcCallBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RpcCallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RpcCall<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RpcCall<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RpcCall");
      ds.field("rpc_type", &self.rpc_type());
      match self.rpc_type() {
        RpcRequest::GetBlockRequest => {
          if let Some(x) = self.rpc_as_get_block_request() {
            ds.field("rpc", &x)
          } else {
            ds.field("rpc", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RpcRequest::GetBlockRangeRequest => {
          if let Some(x) = self.rpc_as_get_block_range_request() {
            ds.field("rpc", &x)
          } else {
            ds.field("rpc", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RpcRequest::GetBlockSliceRequest => {
          if let Some(x) = self.rpc_as_get_block_slice_request() {
            ds.field("rpc", &x)
          } else {
            ds.field("rpc", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RpcRequest::GetUndoSliceRequest => {
          if let Some(x) = self.rpc_as_get_undo_slice_request() {
            ds.field("rpc", &x)
          } else {
            ds.field("rpc", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RpcRequest::GetMempoolRequest => {
          if let Some(x) = self.rpc_as_get_mempool_request() {
            ds.field("rpc", &x)
          } else {
            ds.field("rpc", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("rpc", &x)
        },
      };
      ds.finish()
  }
}
pub enum TxIdOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TxId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TxId<'a> {
  type Inner = TxId<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> TxId<'a> {
  pub const VT_HASH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TxId { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TxIdArgs<'args>
  ) -> flatbuffers::WIPOffset<TxId<'bldr>> {
    let mut builder = TxIdBuilder::new(_fbb);
    if let Some(x) = args.hash { builder.add_hash(x); }
    builder.finish()
  }


  #[inline]
  pub fn hash(&self) -> Option<&'a Hash> {
    self._tab.get::<Hash>(TxId::VT_HASH, None)
  }
}

impl flatbuffers::Verifiable for TxId<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Hash>("hash", Self::VT_HASH, false)?
     .finish();
    Ok(())
  }
}
pub struct TxIdArgs<'a> {
    pub hash: Option<&'a Hash>,
}
impl<'a> Default for TxIdArgs<'a> {
  #[inline]
  fn default() -> Self {
    TxIdArgs {
      hash: None,
    }
  }
}

pub struct TxIdBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TxIdBuilder<'a, 'b> {
  #[inline]
  pub fn add_hash(&mut self, hash: &Hash) {
    self.fbb_.push_slot_always::<&Hash>(TxId::VT_HASH, hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TxIdBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TxIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TxId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TxId<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TxId");
      ds.field("hash", &self.hash());
      ds.finish()
  }
}
pub enum TxOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Tx<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Tx<'a> {
  type Inner = Tx<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Tx<'a> {
  pub const VT_TXID: flatbuffers::VOffsetT = 4;
  pub const VT_RAW: flatbuffers::VOffsetT = 6;
  pub const VT_SPENT_COINS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Tx { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TxArgs<'args>
  ) -> flatbuffers::WIPOffset<Tx<'bldr>> {
    let mut builder = TxBuilder::new(_fbb);
    if let Some(x) = args.spent_coins { builder.add_spent_coins(x); }
    if let Some(x) = args.raw { builder.add_raw(x); }
    if let Some(x) = args.txid { builder.add_txid(x); }
    builder.finish()
  }


  #[inline]
  pub fn txid(&self) -> Option<TxId<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<TxId>>(Tx::VT_TXID, None)
  }
  #[inline]
  pub fn raw(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Tx::VT_RAW, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn spent_coins(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Coin<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Coin>>>>(Tx::VT_SPENT_COINS, None)
  }
}

impl flatbuffers::Verifiable for Tx<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TxId>>("txid", Self::VT_TXID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("raw", Self::VT_RAW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Coin>>>>("spent_coins", Self::VT_SPENT_COINS, false)?
     .finish();
    Ok(())
  }
}
pub struct TxArgs<'a> {
    pub txid: Option<flatbuffers::WIPOffset<TxId<'a>>>,
    pub raw: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub spent_coins: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Coin<'a>>>>>,
}
impl<'a> Default for TxArgs<'a> {
  #[inline]
  fn default() -> Self {
    TxArgs {
      txid: None,
      raw: None,
      spent_coins: None,
    }
  }
}

pub struct TxBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TxBuilder<'a, 'b> {
  #[inline]
  pub fn add_txid(&mut self, txid: flatbuffers::WIPOffset<TxId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TxId>>(Tx::VT_TXID, txid);
  }
  #[inline]
  pub fn add_raw(&mut self, raw: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tx::VT_RAW, raw);
  }
  #[inline]
  pub fn add_spent_coins(&mut self, spent_coins: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Coin<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tx::VT_SPENT_COINS, spent_coins);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TxBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TxBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Tx<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Tx<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Tx");
      ds.field("txid", &self.txid());
      ds.field("raw", &self.raw());
      ds.field("spent_coins", &self.spent_coins());
      ds.finish()
  }
}
pub enum BlockTxOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BlockTx<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockTx<'a> {
  type Inner = BlockTx<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> BlockTx<'a> {
  pub const VT_TX: flatbuffers::VOffsetT = 4;
  pub const VT_DATA_POS: flatbuffers::VOffsetT = 6;
  pub const VT_UNDO_POS: flatbuffers::VOffsetT = 8;
  pub const VT_UNDO_SIZE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BlockTx { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BlockTxArgs<'args>
  ) -> flatbuffers::WIPOffset<BlockTx<'bldr>> {
    let mut builder = BlockTxBuilder::new(_fbb);
    builder.add_undo_size(args.undo_size);
    builder.add_undo_pos(args.undo_pos);
    builder.add_data_pos(args.data_pos);
    if let Some(x) = args.tx { builder.add_tx(x); }
    builder.finish()
  }


  #[inline]
  pub fn tx(&self) -> Option<Tx<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tx>>(BlockTx::VT_TX, None)
  }
  #[inline]
  pub fn data_pos(&self) -> u32 {
    self._tab.get::<u32>(BlockTx::VT_DATA_POS, Some(0)).unwrap()
  }
  #[inline]
  pub fn undo_pos(&self) -> u32 {
    self._tab.get::<u32>(BlockTx::VT_UNDO_POS, Some(0)).unwrap()
  }
  #[inline]
  pub fn undo_size(&self) -> u32 {
    self._tab.get::<u32>(BlockTx::VT_UNDO_SIZE, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for BlockTx<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tx>>("tx", Self::VT_TX, false)?
     .visit_field::<u32>("data_pos", Self::VT_DATA_POS, false)?
     .visit_field::<u32>("undo_pos", Self::VT_UNDO_POS, false)?
     .visit_field::<u32>("undo_size", Self::VT_UNDO_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct BlockTxArgs<'a> {
    pub tx: Option<flatbuffers::WIPOffset<Tx<'a>>>,
    pub data_pos: u32,
    pub undo_pos: u32,
    pub undo_size: u32,
}
impl<'a> Default for BlockTxArgs<'a> {
  #[inline]
  fn default() -> Self {
    BlockTxArgs {
      tx: None,
      data_pos: 0,
      undo_pos: 0,
      undo_size: 0,
    }
  }
}

pub struct BlockTxBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockTxBuilder<'a, 'b> {
  #[inline]
  pub fn add_tx(&mut self, tx: flatbuffers::WIPOffset<Tx<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tx>>(BlockTx::VT_TX, tx);
  }
  #[inline]
  pub fn add_data_pos(&mut self, data_pos: u32) {
    self.fbb_.push_slot::<u32>(BlockTx::VT_DATA_POS, data_pos, 0);
  }
  #[inline]
  pub fn add_undo_pos(&mut self, undo_pos: u32) {
    self.fbb_.push_slot::<u32>(BlockTx::VT_UNDO_POS, undo_pos, 0);
  }
  #[inline]
  pub fn add_undo_size(&mut self, undo_size: u32) {
    self.fbb_.push_slot::<u32>(BlockTx::VT_UNDO_SIZE, undo_size, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockTxBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockTxBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockTx<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BlockTx<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BlockTx");
      ds.field("tx", &self.tx());
      ds.field("data_pos", &self.data_pos());
      ds.field("undo_pos", &self.undo_pos());
      ds.field("undo_size", &self.undo_size());
      ds.finish()
  }
}
pub enum MempoolTxOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MempoolTx<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MempoolTx<'a> {
  type Inner = MempoolTx<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> MempoolTx<'a> {
  pub const VT_TX: flatbuffers::VOffsetT = 4;
  pub const VT_TIME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MempoolTx { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MempoolTxArgs<'args>
  ) -> flatbuffers::WIPOffset<MempoolTx<'bldr>> {
    let mut builder = MempoolTxBuilder::new(_fbb);
    builder.add_time(args.time);
    if let Some(x) = args.tx { builder.add_tx(x); }
    builder.finish()
  }


  #[inline]
  pub fn tx(&self) -> Option<Tx<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tx>>(MempoolTx::VT_TX, None)
  }
  #[inline]
  pub fn time(&self) -> i64 {
    self._tab.get::<i64>(MempoolTx::VT_TIME, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for MempoolTx<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tx>>("tx", Self::VT_TX, false)?
     .visit_field::<i64>("time", Self::VT_TIME, false)?
     .finish();
    Ok(())
  }
}
pub struct MempoolTxArgs<'a> {
    pub tx: Option<flatbuffers::WIPOffset<Tx<'a>>>,
    pub time: i64,
}
impl<'a> Default for MempoolTxArgs<'a> {
  #[inline]
  fn default() -> Self {
    MempoolTxArgs {
      tx: None,
      time: 0,
    }
  }
}

pub struct MempoolTxBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MempoolTxBuilder<'a, 'b> {
  #[inline]
  pub fn add_tx(&mut self, tx: flatbuffers::WIPOffset<Tx<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tx>>(MempoolTx::VT_TX, tx);
  }
  #[inline]
  pub fn add_time(&mut self, time: i64) {
    self.fbb_.push_slot::<i64>(MempoolTx::VT_TIME, time, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MempoolTxBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MempoolTxBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MempoolTx<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MempoolTx<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MempoolTx");
      ds.field("tx", &self.tx());
      ds.field("time", &self.time());
      ds.finish()
  }
}
pub enum CoinOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Coin<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Coin<'a> {
  type Inner = Coin<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Coin<'a> {
  pub const VT_TX_OUT: flatbuffers::VOffsetT = 4;
  pub const VT_IS_COINBASE: flatbuffers::VOffsetT = 6;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Coin { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CoinArgs<'args>
  ) -> flatbuffers::WIPOffset<Coin<'bldr>> {
    let mut builder = CoinBuilder::new(_fbb);
    builder.add_height(args.height);
    if let Some(x) = args.tx_out { builder.add_tx_out(x); }
    builder.add_is_coinbase(args.is_coinbase);
    builder.finish()
  }


  #[inline]
  pub fn tx_out(&self) -> Option<TxOut<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<TxOut>>(Coin::VT_TX_OUT, None)
  }
  #[inline]
  pub fn is_coinbase(&self) -> bool {
    self._tab.get::<bool>(Coin::VT_IS_COINBASE, Some(false)).unwrap()
  }
  #[inline]
  pub fn height(&self) -> i32 {
    self._tab.get::<i32>(Coin::VT_HEIGHT, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for Coin<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TxOut>>("tx_out", Self::VT_TX_OUT, false)?
     .visit_field::<bool>("is_coinbase", Self::VT_IS_COINBASE, false)?
     .visit_field::<i32>("height", Self::VT_HEIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct CoinArgs<'a> {
    pub tx_out: Option<flatbuffers::WIPOffset<TxOut<'a>>>,
    pub is_coinbase: bool,
    pub height: i32,
}
impl<'a> Default for CoinArgs<'a> {
  #[inline]
  fn default() -> Self {
    CoinArgs {
      tx_out: None,
      is_coinbase: false,
      height: 0,
    }
  }
}

pub struct CoinBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CoinBuilder<'a, 'b> {
  #[inline]
  pub fn add_tx_out(&mut self, tx_out: flatbuffers::WIPOffset<TxOut<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TxOut>>(Coin::VT_TX_OUT, tx_out);
  }
  #[inline]
  pub fn add_is_coinbase(&mut self, is_coinbase: bool) {
    self.fbb_.push_slot::<bool>(Coin::VT_IS_COINBASE, is_coinbase, false);
  }
  #[inline]
  pub fn add_height(&mut self, height: i32) {
    self.fbb_.push_slot::<i32>(Coin::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CoinBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CoinBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Coin<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Coin<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Coin");
      ds.field("tx_out", &self.tx_out());
      ds.field("is_coinbase", &self.is_coinbase());
      ds.field("height", &self.height());
      ds.finish()
  }
}
pub enum TxOutOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TxOut<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TxOut<'a> {
  type Inner = TxOut<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> TxOut<'a> {
  pub const VT_AMOUNT: flatbuffers::VOffsetT = 4;
  pub const VT_SCRIPT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TxOut { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TxOutArgs<'args>
  ) -> flatbuffers::WIPOffset<TxOut<'bldr>> {
    let mut builder = TxOutBuilder::new(_fbb);
    builder.add_amount(args.amount);
    if let Some(x) = args.script { builder.add_script(x); }
    builder.finish()
  }


  #[inline]
  pub fn amount(&self) -> u64 {
    self._tab.get::<u64>(TxOut::VT_AMOUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn script(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(TxOut::VT_SCRIPT, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for TxOut<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("script", Self::VT_SCRIPT, false)?
     .finish();
    Ok(())
  }
}
pub struct TxOutArgs<'a> {
    pub amount: u64,
    pub script: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for TxOutArgs<'a> {
  #[inline]
  fn default() -> Self {
    TxOutArgs {
      amount: 0,
      script: None,
    }
  }
}

pub struct TxOutBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TxOutBuilder<'a, 'b> {
  #[inline]
  pub fn add_amount(&mut self, amount: u64) {
    self.fbb_.push_slot::<u64>(TxOut::VT_AMOUNT, amount, 0);
  }
  #[inline]
  pub fn add_script(&mut self, script: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TxOut::VT_SCRIPT, script);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TxOutBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TxOutBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TxOut<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TxOut<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TxOut");
      ds.field("amount", &self.amount());
      ds.field("script", &self.script());
      ds.finish()
  }
}
pub enum BlockHeightOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BlockHeight<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockHeight<'a> {
  type Inner = BlockHeight<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> BlockHeight<'a> {
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BlockHeight { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BlockHeightArgs
  ) -> flatbuffers::WIPOffset<BlockHeight<'bldr>> {
    let mut builder = BlockHeightBuilder::new(_fbb);
    builder.add_height(args.height);
    builder.finish()
  }


  #[inline]
  pub fn height(&self) -> i32 {
    self._tab.get::<i32>(BlockHeight::VT_HEIGHT, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for BlockHeight<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("height", Self::VT_HEIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct BlockHeightArgs {
    pub height: i32,
}
impl<'a> Default for BlockHeightArgs {
  #[inline]
  fn default() -> Self {
    BlockHeightArgs {
      height: 0,
    }
  }
}

pub struct BlockHeightBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockHeightBuilder<'a, 'b> {
  #[inline]
  pub fn add_height(&mut self, height: i32) {
    self.fbb_.push_slot::<i32>(BlockHeight::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockHeightBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockHeightBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockHeight<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BlockHeight<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BlockHeight");
      ds.field("height", &self.height());
      ds.finish()
  }
}
pub enum BlockHashOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BlockHash<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockHash<'a> {
  type Inner = BlockHash<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> BlockHash<'a> {
  pub const VT_HASH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BlockHash { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BlockHashArgs<'args>
  ) -> flatbuffers::WIPOffset<BlockHash<'bldr>> {
    let mut builder = BlockHashBuilder::new(_fbb);
    if let Some(x) = args.hash { builder.add_hash(x); }
    builder.finish()
  }


  #[inline]
  pub fn hash(&self) -> Option<&'a Hash> {
    self._tab.get::<Hash>(BlockHash::VT_HASH, None)
  }
}

impl flatbuffers::Verifiable for BlockHash<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Hash>("hash", Self::VT_HASH, false)?
     .finish();
    Ok(())
  }
}
pub struct BlockHashArgs<'a> {
    pub hash: Option<&'a Hash>,
}
impl<'a> Default for BlockHashArgs<'a> {
  #[inline]
  fn default() -> Self {
    BlockHashArgs {
      hash: None,
    }
  }
}

pub struct BlockHashBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockHashBuilder<'a, 'b> {
  #[inline]
  pub fn add_hash(&mut self, hash: &Hash) {
    self.fbb_.push_slot_always::<&Hash>(BlockHash::VT_HASH, hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockHashBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockHashBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockHash<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BlockHash<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BlockHash");
      ds.field("hash", &self.hash());
      ds.finish()
  }
}
pub enum BlockHeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BlockHeader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockHeader<'a> {
  type Inner = BlockHeader<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> BlockHeader<'a> {
  pub const VT_RAW: flatbuffers::VOffsetT = 4;
  pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 6;
  pub const VT_PREV_BLOCK_HASH: flatbuffers::VOffsetT = 8;
  pub const VT_N_BITS: flatbuffers::VOffsetT = 10;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BlockHeader { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BlockHeaderArgs<'args>
  ) -> flatbuffers::WIPOffset<BlockHeader<'bldr>> {
    let mut builder = BlockHeaderBuilder::new(_fbb);
    builder.add_timestamp(args.timestamp);
    builder.add_n_bits(args.n_bits);
    if let Some(x) = args.prev_block_hash { builder.add_prev_block_hash(x); }
    if let Some(x) = args.block_hash { builder.add_block_hash(x); }
    if let Some(x) = args.raw { builder.add_raw(x); }
    builder.finish()
  }


  #[inline]
  pub fn raw(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(BlockHeader::VT_RAW, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn block_hash(&self) -> Option<BlockHash<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BlockHash>>(BlockHeader::VT_BLOCK_HASH, None)
  }
  #[inline]
  pub fn prev_block_hash(&self) -> Option<BlockHash<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BlockHash>>(BlockHeader::VT_PREV_BLOCK_HASH, None)
  }
  #[inline]
  pub fn n_bits(&self) -> u32 {
    self._tab.get::<u32>(BlockHeader::VT_N_BITS, Some(0)).unwrap()
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    self._tab.get::<u64>(BlockHeader::VT_TIMESTAMP, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for BlockHeader<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("raw", Self::VT_RAW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BlockHash>>("block_hash", Self::VT_BLOCK_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BlockHash>>("prev_block_hash", Self::VT_PREV_BLOCK_HASH, false)?
     .visit_field::<u32>("n_bits", Self::VT_N_BITS, false)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .finish();
    Ok(())
  }
}
pub struct BlockHeaderArgs<'a> {
    pub raw: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub block_hash: Option<flatbuffers::WIPOffset<BlockHash<'a>>>,
    pub prev_block_hash: Option<flatbuffers::WIPOffset<BlockHash<'a>>>,
    pub n_bits: u32,
    pub timestamp: u64,
}
impl<'a> Default for BlockHeaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    BlockHeaderArgs {
      raw: None,
      block_hash: None,
      prev_block_hash: None,
      n_bits: 0,
      timestamp: 0,
    }
  }
}

pub struct BlockHeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockHeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_raw(&mut self, raw: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BlockHeader::VT_RAW, raw);
  }
  #[inline]
  pub fn add_block_hash(&mut self, block_hash: flatbuffers::WIPOffset<BlockHash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BlockHash>>(BlockHeader::VT_BLOCK_HASH, block_hash);
  }
  #[inline]
  pub fn add_prev_block_hash(&mut self, prev_block_hash: flatbuffers::WIPOffset<BlockHash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BlockHash>>(BlockHeader::VT_PREV_BLOCK_HASH, prev_block_hash);
  }
  #[inline]
  pub fn add_n_bits(&mut self, n_bits: u32) {
    self.fbb_.push_slot::<u32>(BlockHeader::VT_N_BITS, n_bits, 0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(BlockHeader::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockHeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockHeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockHeader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BlockHeader<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BlockHeader");
      ds.field("raw", &self.raw());
      ds.field("block_hash", &self.block_hash());
      ds.field("prev_block_hash", &self.prev_block_hash());
      ds.field("n_bits", &self.n_bits());
      ds.field("timestamp", &self.timestamp());
      ds.finish()
  }
}
pub enum BlockOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Block<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Block<'a> {
  type Inner = Block<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Block<'a> {
  pub const VT_HEADER: flatbuffers::VOffsetT = 4;
  pub const VT_METADATA: flatbuffers::VOffsetT = 6;
  pub const VT_TXS: flatbuffers::VOffsetT = 8;
  pub const VT_FILE_NUM: flatbuffers::VOffsetT = 10;
  pub const VT_DATA_POS: flatbuffers::VOffsetT = 12;
  pub const VT_UNDO_POS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Block { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BlockArgs<'args>
  ) -> flatbuffers::WIPOffset<Block<'bldr>> {
    let mut builder = BlockBuilder::new(_fbb);
    builder.add_undo_pos(args.undo_pos);
    builder.add_data_pos(args.data_pos);
    builder.add_file_num(args.file_num);
    if let Some(x) = args.txs { builder.add_txs(x); }
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    if let Some(x) = args.header { builder.add_header(x); }
    builder.finish()
  }


  #[inline]
  pub fn header(&self) -> Option<BlockHeader<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BlockHeader>>(Block::VT_HEADER, None)
  }
  #[inline]
  pub fn metadata(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BlockMetadata<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BlockMetadata>>>>(Block::VT_METADATA, None)
  }
  #[inline]
  pub fn txs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BlockTx<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BlockTx>>>>(Block::VT_TXS, None)
  }
  #[inline]
  pub fn file_num(&self) -> u32 {
    self._tab.get::<u32>(Block::VT_FILE_NUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn data_pos(&self) -> u32 {
    self._tab.get::<u32>(Block::VT_DATA_POS, Some(0)).unwrap()
  }
  #[inline]
  pub fn undo_pos(&self) -> u32 {
    self._tab.get::<u32>(Block::VT_UNDO_POS, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for Block<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BlockHeader>>("header", Self::VT_HEADER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BlockMetadata>>>>("metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BlockTx>>>>("txs", Self::VT_TXS, false)?
     .visit_field::<u32>("file_num", Self::VT_FILE_NUM, false)?
     .visit_field::<u32>("data_pos", Self::VT_DATA_POS, false)?
     .visit_field::<u32>("undo_pos", Self::VT_UNDO_POS, false)?
     .finish();
    Ok(())
  }
}
pub struct BlockArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<BlockHeader<'a>>>,
    pub metadata: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BlockMetadata<'a>>>>>,
    pub txs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BlockTx<'a>>>>>,
    pub file_num: u32,
    pub data_pos: u32,
    pub undo_pos: u32,
}
impl<'a> Default for BlockArgs<'a> {
  #[inline]
  fn default() -> Self {
    BlockArgs {
      header: None,
      metadata: None,
      txs: None,
      file_num: 0,
      data_pos: 0,
      undo_pos: 0,
    }
  }
}

pub struct BlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<BlockHeader<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BlockHeader>>(Block::VT_HEADER, header);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BlockMetadata<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_txs(&mut self, txs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BlockTx<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_TXS, txs);
  }
  #[inline]
  pub fn add_file_num(&mut self, file_num: u32) {
    self.fbb_.push_slot::<u32>(Block::VT_FILE_NUM, file_num, 0);
  }
  #[inline]
  pub fn add_data_pos(&mut self, data_pos: u32) {
    self.fbb_.push_slot::<u32>(Block::VT_DATA_POS, data_pos, 0);
  }
  #[inline]
  pub fn add_undo_pos(&mut self, undo_pos: u32) {
    self.fbb_.push_slot::<u32>(Block::VT_UNDO_POS, undo_pos, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Block<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Block");
      ds.field("header", &self.header());
      ds.field("metadata", &self.metadata());
      ds.field("txs", &self.txs());
      ds.field("file_num", &self.file_num());
      ds.field("data_pos", &self.data_pos());
      ds.field("undo_pos", &self.undo_pos());
      ds.finish()
  }
}
pub enum BlockMetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BlockMetadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockMetadata<'a> {
  type Inner = BlockMetadata<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> BlockMetadata<'a> {
  pub const VT_FIELD_ID: flatbuffers::VOffsetT = 4;
  pub const VT_FIELD_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BlockMetadata { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BlockMetadataArgs<'args>
  ) -> flatbuffers::WIPOffset<BlockMetadata<'bldr>> {
    let mut builder = BlockMetadataBuilder::new(_fbb);
    if let Some(x) = args.field_value { builder.add_field_value(x); }
    builder.add_field_id(args.field_id);
    builder.finish()
  }


  #[inline]
  pub fn field_id(&self) -> u32 {
    self._tab.get::<u32>(BlockMetadata::VT_FIELD_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn field_value(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(BlockMetadata::VT_FIELD_VALUE, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for BlockMetadata<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("field_id", Self::VT_FIELD_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("field_value", Self::VT_FIELD_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct BlockMetadataArgs<'a> {
    pub field_id: u32,
    pub field_value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for BlockMetadataArgs<'a> {
  #[inline]
  fn default() -> Self {
    BlockMetadataArgs {
      field_id: 0,
      field_value: None,
    }
  }
}

pub struct BlockMetadataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockMetadataBuilder<'a, 'b> {
  #[inline]
  pub fn add_field_id(&mut self, field_id: u32) {
    self.fbb_.push_slot::<u32>(BlockMetadata::VT_FIELD_ID, field_id, 0);
  }
  #[inline]
  pub fn add_field_value(&mut self, field_value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BlockMetadata::VT_FIELD_VALUE, field_value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockMetadataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockMetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockMetadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BlockMetadata<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BlockMetadata");
      ds.field("field_id", &self.field_id());
      ds.field("field_value", &self.field_value());
      ds.finish()
  }
}
pub enum UpdatedBlockTipOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UpdatedBlockTip<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UpdatedBlockTip<'a> {
  type Inner = UpdatedBlockTip<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> UpdatedBlockTip<'a> {
  pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UpdatedBlockTip { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UpdatedBlockTipArgs<'args>
  ) -> flatbuffers::WIPOffset<UpdatedBlockTip<'bldr>> {
    let mut builder = UpdatedBlockTipBuilder::new(_fbb);
    if let Some(x) = args.block_hash { builder.add_block_hash(x); }
    builder.finish()
  }


  #[inline]
  pub fn block_hash(&self) -> Option<BlockHash<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BlockHash>>(UpdatedBlockTip::VT_BLOCK_HASH, None)
  }
}

impl flatbuffers::Verifiable for UpdatedBlockTip<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BlockHash>>("block_hash", Self::VT_BLOCK_HASH, false)?
     .finish();
    Ok(())
  }
}
pub struct UpdatedBlockTipArgs<'a> {
    pub block_hash: Option<flatbuffers::WIPOffset<BlockHash<'a>>>,
}
impl<'a> Default for UpdatedBlockTipArgs<'a> {
  #[inline]
  fn default() -> Self {
    UpdatedBlockTipArgs {
      block_hash: None,
    }
  }
}

pub struct UpdatedBlockTipBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UpdatedBlockTipBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_hash(&mut self, block_hash: flatbuffers::WIPOffset<BlockHash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BlockHash>>(UpdatedBlockTip::VT_BLOCK_HASH, block_hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UpdatedBlockTipBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UpdatedBlockTipBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UpdatedBlockTip<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UpdatedBlockTip<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UpdatedBlockTip");
      ds.field("block_hash", &self.block_hash());
      ds.finish()
  }
}
pub enum TransactionAddedToMempoolOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransactionAddedToMempool<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransactionAddedToMempool<'a> {
  type Inner = TransactionAddedToMempool<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> TransactionAddedToMempool<'a> {
  pub const VT_MEMPOOL_TX: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TransactionAddedToMempool { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TransactionAddedToMempoolArgs<'args>
  ) -> flatbuffers::WIPOffset<TransactionAddedToMempool<'bldr>> {
    let mut builder = TransactionAddedToMempoolBuilder::new(_fbb);
    if let Some(x) = args.mempool_tx { builder.add_mempool_tx(x); }
    builder.finish()
  }


  #[inline]
  pub fn mempool_tx(&self) -> Option<MempoolTx<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<MempoolTx>>(TransactionAddedToMempool::VT_MEMPOOL_TX, None)
  }
}

impl flatbuffers::Verifiable for TransactionAddedToMempool<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<MempoolTx>>("mempool_tx", Self::VT_MEMPOOL_TX, false)?
     .finish();
    Ok(())
  }
}
pub struct TransactionAddedToMempoolArgs<'a> {
    pub mempool_tx: Option<flatbuffers::WIPOffset<MempoolTx<'a>>>,
}
impl<'a> Default for TransactionAddedToMempoolArgs<'a> {
  #[inline]
  fn default() -> Self {
    TransactionAddedToMempoolArgs {
      mempool_tx: None,
    }
  }
}

pub struct TransactionAddedToMempoolBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransactionAddedToMempoolBuilder<'a, 'b> {
  #[inline]
  pub fn add_mempool_tx(&mut self, mempool_tx: flatbuffers::WIPOffset<MempoolTx<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MempoolTx>>(TransactionAddedToMempool::VT_MEMPOOL_TX, mempool_tx);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransactionAddedToMempoolBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransactionAddedToMempoolBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransactionAddedToMempool<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TransactionAddedToMempool<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TransactionAddedToMempool");
      ds.field("mempool_tx", &self.mempool_tx());
      ds.finish()
  }
}
pub enum TransactionRemovedFromMempoolOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransactionRemovedFromMempool<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransactionRemovedFromMempool<'a> {
  type Inner = TransactionRemovedFromMempool<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> TransactionRemovedFromMempool<'a> {
  pub const VT_TXID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TransactionRemovedFromMempool { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TransactionRemovedFromMempoolArgs<'args>
  ) -> flatbuffers::WIPOffset<TransactionRemovedFromMempool<'bldr>> {
    let mut builder = TransactionRemovedFromMempoolBuilder::new(_fbb);
    if let Some(x) = args.txid { builder.add_txid(x); }
    builder.finish()
  }


  #[inline]
  pub fn txid(&self) -> Option<TxId<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<TxId>>(TransactionRemovedFromMempool::VT_TXID, None)
  }
}

impl flatbuffers::Verifiable for TransactionRemovedFromMempool<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TxId>>("txid", Self::VT_TXID, false)?
     .finish();
    Ok(())
  }
}
pub struct TransactionRemovedFromMempoolArgs<'a> {
    pub txid: Option<flatbuffers::WIPOffset<TxId<'a>>>,
}
impl<'a> Default for TransactionRemovedFromMempoolArgs<'a> {
  #[inline]
  fn default() -> Self {
    TransactionRemovedFromMempoolArgs {
      txid: None,
    }
  }
}

pub struct TransactionRemovedFromMempoolBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransactionRemovedFromMempoolBuilder<'a, 'b> {
  #[inline]
  pub fn add_txid(&mut self, txid: flatbuffers::WIPOffset<TxId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TxId>>(TransactionRemovedFromMempool::VT_TXID, txid);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransactionRemovedFromMempoolBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransactionRemovedFromMempoolBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransactionRemovedFromMempool<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TransactionRemovedFromMempool<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TransactionRemovedFromMempool");
      ds.field("txid", &self.txid());
      ds.finish()
  }
}
pub enum BlockConnectedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BlockConnected<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockConnected<'a> {
  type Inner = BlockConnected<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> BlockConnected<'a> {
  pub const VT_BLOCK: flatbuffers::VOffsetT = 4;
  pub const VT_TXS_CONFLICTED: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BlockConnected { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BlockConnectedArgs<'args>
  ) -> flatbuffers::WIPOffset<BlockConnected<'bldr>> {
    let mut builder = BlockConnectedBuilder::new(_fbb);
    if let Some(x) = args.txs_conflicted { builder.add_txs_conflicted(x); }
    if let Some(x) = args.block { builder.add_block(x); }
    builder.finish()
  }


  #[inline]
  pub fn block(&self) -> Option<Block<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Block>>(BlockConnected::VT_BLOCK, None)
  }
  #[inline]
  pub fn txs_conflicted(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxId<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxId>>>>(BlockConnected::VT_TXS_CONFLICTED, None)
  }
}

impl flatbuffers::Verifiable for BlockConnected<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Block>>("block", Self::VT_BLOCK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TxId>>>>("txs_conflicted", Self::VT_TXS_CONFLICTED, false)?
     .finish();
    Ok(())
  }
}
pub struct BlockConnectedArgs<'a> {
    pub block: Option<flatbuffers::WIPOffset<Block<'a>>>,
    pub txs_conflicted: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxId<'a>>>>>,
}
impl<'a> Default for BlockConnectedArgs<'a> {
  #[inline]
  fn default() -> Self {
    BlockConnectedArgs {
      block: None,
      txs_conflicted: None,
    }
  }
}

pub struct BlockConnectedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockConnectedBuilder<'a, 'b> {
  #[inline]
  pub fn add_block(&mut self, block: flatbuffers::WIPOffset<Block<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Block>>(BlockConnected::VT_BLOCK, block);
  }
  #[inline]
  pub fn add_txs_conflicted(&mut self, txs_conflicted: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TxId<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BlockConnected::VT_TXS_CONFLICTED, txs_conflicted);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockConnectedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockConnectedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockConnected<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BlockConnected<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BlockConnected");
      ds.field("block", &self.block());
      ds.field("txs_conflicted", &self.txs_conflicted());
      ds.finish()
  }
}
pub enum BlockDisconnectedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BlockDisconnected<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockDisconnected<'a> {
  type Inner = BlockDisconnected<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> BlockDisconnected<'a> {
  pub const VT_BLOCK: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BlockDisconnected { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BlockDisconnectedArgs<'args>
  ) -> flatbuffers::WIPOffset<BlockDisconnected<'bldr>> {
    let mut builder = BlockDisconnectedBuilder::new(_fbb);
    if let Some(x) = args.block { builder.add_block(x); }
    builder.finish()
  }


  #[inline]
  pub fn block(&self) -> Option<Block<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Block>>(BlockDisconnected::VT_BLOCK, None)
  }
}

impl flatbuffers::Verifiable for BlockDisconnected<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Block>>("block", Self::VT_BLOCK, false)?
     .finish();
    Ok(())
  }
}
pub struct BlockDisconnectedArgs<'a> {
    pub block: Option<flatbuffers::WIPOffset<Block<'a>>>,
}
impl<'a> Default for BlockDisconnectedArgs<'a> {
  #[inline]
  fn default() -> Self {
    BlockDisconnectedArgs {
      block: None,
    }
  }
}

pub struct BlockDisconnectedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockDisconnectedBuilder<'a, 'b> {
  #[inline]
  pub fn add_block(&mut self, block: flatbuffers::WIPOffset<Block<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Block>>(BlockDisconnected::VT_BLOCK, block);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockDisconnectedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockDisconnectedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockDisconnected<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BlockDisconnected<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BlockDisconnected");
      ds.field("block", &self.block());
      ds.finish()
  }
}
pub enum ChainStateFlushedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ChainStateFlushed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ChainStateFlushed<'a> {
  type Inner = ChainStateFlushed<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ChainStateFlushed<'a> {
  pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ChainStateFlushed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ChainStateFlushedArgs<'args>
  ) -> flatbuffers::WIPOffset<ChainStateFlushed<'bldr>> {
    let mut builder = ChainStateFlushedBuilder::new(_fbb);
    if let Some(x) = args.block_hash { builder.add_block_hash(x); }
    builder.finish()
  }


  #[inline]
  pub fn block_hash(&self) -> Option<BlockHash<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BlockHash>>(ChainStateFlushed::VT_BLOCK_HASH, None)
  }
}

impl flatbuffers::Verifiable for ChainStateFlushed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BlockHash>>("block_hash", Self::VT_BLOCK_HASH, false)?
     .finish();
    Ok(())
  }
}
pub struct ChainStateFlushedArgs<'a> {
    pub block_hash: Option<flatbuffers::WIPOffset<BlockHash<'a>>>,
}
impl<'a> Default for ChainStateFlushedArgs<'a> {
  #[inline]
  fn default() -> Self {
    ChainStateFlushedArgs {
      block_hash: None,
    }
  }
}

pub struct ChainStateFlushedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ChainStateFlushedBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_hash(&mut self, block_hash: flatbuffers::WIPOffset<BlockHash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BlockHash>>(ChainStateFlushed::VT_BLOCK_HASH, block_hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ChainStateFlushedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ChainStateFlushedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ChainStateFlushed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ChainStateFlushed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ChainStateFlushed");
      ds.field("block_hash", &self.block_hash());
      ds.finish()
  }
}
pub enum GetBlockRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetBlockRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetBlockRequest<'a> {
  type Inner = GetBlockRequest<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GetBlockRequest<'a> {
  pub const VT_BLOCK_ID_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_BLOCK_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetBlockRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetBlockRequestArgs
  ) -> flatbuffers::WIPOffset<GetBlockRequest<'bldr>> {
    let mut builder = GetBlockRequestBuilder::new(_fbb);
    if let Some(x) = args.block_id { builder.add_block_id(x); }
    builder.add_block_id_type(args.block_id_type);
    builder.finish()
  }


  #[inline]
  pub fn block_id_type(&self) -> BlockIdentifier {
    self._tab.get::<BlockIdentifier>(GetBlockRequest::VT_BLOCK_ID_TYPE, Some(BlockIdentifier::NONE)).unwrap()
  }
  #[inline]
  pub fn block_id(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(GetBlockRequest::VT_BLOCK_ID, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn block_id_as_height(&self) -> Option<BlockHeight<'a>> {
    if self.block_id_type() == BlockIdentifier::Height {
      self.block_id().map(BlockHeight::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn block_id_as_hash(&self) -> Option<BlockHash<'a>> {
    if self.block_id_type() == BlockIdentifier::Hash {
      self.block_id().map(BlockHash::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for GetBlockRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<BlockIdentifier, _>("block_id_type", Self::VT_BLOCK_ID_TYPE, "block_id", Self::VT_BLOCK_ID, false, |key, v, pos| {
        match key {
          BlockIdentifier::Height => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BlockHeight>>("BlockIdentifier::Height", pos),
          BlockIdentifier::Hash => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BlockHash>>("BlockIdentifier::Hash", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct GetBlockRequestArgs {
    pub block_id_type: BlockIdentifier,
    pub block_id: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for GetBlockRequestArgs {
  #[inline]
  fn default() -> Self {
    GetBlockRequestArgs {
      block_id_type: BlockIdentifier::NONE,
      block_id: None,
    }
  }
}

pub struct GetBlockRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetBlockRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_id_type(&mut self, block_id_type: BlockIdentifier) {
    self.fbb_.push_slot::<BlockIdentifier>(GetBlockRequest::VT_BLOCK_ID_TYPE, block_id_type, BlockIdentifier::NONE);
  }
  #[inline]
  pub fn add_block_id(&mut self, block_id: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetBlockRequest::VT_BLOCK_ID, block_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetBlockRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetBlockRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetBlockRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetBlockRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetBlockRequest");
      ds.field("block_id_type", &self.block_id_type());
      match self.block_id_type() {
        BlockIdentifier::Height => {
          if let Some(x) = self.block_id_as_height() {
            ds.field("block_id", &x)
          } else {
            ds.field("block_id", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BlockIdentifier::Hash => {
          if let Some(x) = self.block_id_as_hash() {
            ds.field("block_id", &x)
          } else {
            ds.field("block_id", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("block_id", &x)
        },
      };
      ds.finish()
  }
}
pub enum GetBlockResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetBlockResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetBlockResponse<'a> {
  type Inner = GetBlockResponse<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GetBlockResponse<'a> {
  pub const VT_BLOCK: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetBlockResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetBlockResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<GetBlockResponse<'bldr>> {
    let mut builder = GetBlockResponseBuilder::new(_fbb);
    if let Some(x) = args.block { builder.add_block(x); }
    builder.finish()
  }


  #[inline]
  pub fn block(&self) -> Option<Block<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Block>>(GetBlockResponse::VT_BLOCK, None)
  }
}

impl flatbuffers::Verifiable for GetBlockResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Block>>("block", Self::VT_BLOCK, false)?
     .finish();
    Ok(())
  }
}
pub struct GetBlockResponseArgs<'a> {
    pub block: Option<flatbuffers::WIPOffset<Block<'a>>>,
}
impl<'a> Default for GetBlockResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetBlockResponseArgs {
      block: None,
    }
  }
}

pub struct GetBlockResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetBlockResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_block(&mut self, block: flatbuffers::WIPOffset<Block<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Block>>(GetBlockResponse::VT_BLOCK, block);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetBlockResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetBlockResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetBlockResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetBlockResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetBlockResponse");
      ds.field("block", &self.block());
      ds.finish()
  }
}
pub enum GetBlockRangeRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetBlockRangeRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetBlockRangeRequest<'a> {
  type Inner = GetBlockRangeRequest<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GetBlockRangeRequest<'a> {
  pub const VT_START_HEIGHT: flatbuffers::VOffsetT = 4;
  pub const VT_NUM_BLOCKS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetBlockRangeRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetBlockRangeRequestArgs
  ) -> flatbuffers::WIPOffset<GetBlockRangeRequest<'bldr>> {
    let mut builder = GetBlockRangeRequestBuilder::new(_fbb);
    builder.add_num_blocks(args.num_blocks);
    builder.add_start_height(args.start_height);
    builder.finish()
  }


  #[inline]
  pub fn start_height(&self) -> i32 {
    self._tab.get::<i32>(GetBlockRangeRequest::VT_START_HEIGHT, Some(0)).unwrap()
  }
  #[inline]
  pub fn num_blocks(&self) -> u32 {
    self._tab.get::<u32>(GetBlockRangeRequest::VT_NUM_BLOCKS, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for GetBlockRangeRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("start_height", Self::VT_START_HEIGHT, false)?
     .visit_field::<u32>("num_blocks", Self::VT_NUM_BLOCKS, false)?
     .finish();
    Ok(())
  }
}
pub struct GetBlockRangeRequestArgs {
    pub start_height: i32,
    pub num_blocks: u32,
}
impl<'a> Default for GetBlockRangeRequestArgs {
  #[inline]
  fn default() -> Self {
    GetBlockRangeRequestArgs {
      start_height: 0,
      num_blocks: 0,
    }
  }
}

pub struct GetBlockRangeRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetBlockRangeRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_start_height(&mut self, start_height: i32) {
    self.fbb_.push_slot::<i32>(GetBlockRangeRequest::VT_START_HEIGHT, start_height, 0);
  }
  #[inline]
  pub fn add_num_blocks(&mut self, num_blocks: u32) {
    self.fbb_.push_slot::<u32>(GetBlockRangeRequest::VT_NUM_BLOCKS, num_blocks, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetBlockRangeRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetBlockRangeRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetBlockRangeRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetBlockRangeRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetBlockRangeRequest");
      ds.field("start_height", &self.start_height());
      ds.field("num_blocks", &self.num_blocks());
      ds.finish()
  }
}
pub enum GetBlockRangeResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetBlockRangeResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetBlockRangeResponse<'a> {
  type Inner = GetBlockRangeResponse<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GetBlockRangeResponse<'a> {
  pub const VT_BLOCKS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetBlockRangeResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetBlockRangeResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<GetBlockRangeResponse<'bldr>> {
    let mut builder = GetBlockRangeResponseBuilder::new(_fbb);
    if let Some(x) = args.blocks { builder.add_blocks(x); }
    builder.finish()
  }


  #[inline]
  pub fn blocks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Block<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Block>>>>(GetBlockRangeResponse::VT_BLOCKS, None)
  }
}

impl flatbuffers::Verifiable for GetBlockRangeResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Block>>>>("blocks", Self::VT_BLOCKS, false)?
     .finish();
    Ok(())
  }
}
pub struct GetBlockRangeResponseArgs<'a> {
    pub blocks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Block<'a>>>>>,
}
impl<'a> Default for GetBlockRangeResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetBlockRangeResponseArgs {
      blocks: None,
    }
  }
}

pub struct GetBlockRangeResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetBlockRangeResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_blocks(&mut self, blocks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Block<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetBlockRangeResponse::VT_BLOCKS, blocks);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetBlockRangeResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetBlockRangeResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetBlockRangeResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetBlockRangeResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetBlockRangeResponse");
      ds.field("blocks", &self.blocks());
      ds.finish()
  }
}
pub enum GetBlockSliceRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetBlockSliceRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetBlockSliceRequest<'a> {
  type Inner = GetBlockSliceRequest<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GetBlockSliceRequest<'a> {
  pub const VT_FILE_NUM: flatbuffers::VOffsetT = 4;
  pub const VT_DATA_POS: flatbuffers::VOffsetT = 6;
  pub const VT_NUM_BYTES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetBlockSliceRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetBlockSliceRequestArgs
  ) -> flatbuffers::WIPOffset<GetBlockSliceRequest<'bldr>> {
    let mut builder = GetBlockSliceRequestBuilder::new(_fbb);
    builder.add_num_bytes(args.num_bytes);
    builder.add_data_pos(args.data_pos);
    builder.add_file_num(args.file_num);
    builder.finish()
  }


  #[inline]
  pub fn file_num(&self) -> u32 {
    self._tab.get::<u32>(GetBlockSliceRequest::VT_FILE_NUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn data_pos(&self) -> u32 {
    self._tab.get::<u32>(GetBlockSliceRequest::VT_DATA_POS, Some(0)).unwrap()
  }
  #[inline]
  pub fn num_bytes(&self) -> u32 {
    self._tab.get::<u32>(GetBlockSliceRequest::VT_NUM_BYTES, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for GetBlockSliceRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("file_num", Self::VT_FILE_NUM, false)?
     .visit_field::<u32>("data_pos", Self::VT_DATA_POS, false)?
     .visit_field::<u32>("num_bytes", Self::VT_NUM_BYTES, false)?
     .finish();
    Ok(())
  }
}
pub struct GetBlockSliceRequestArgs {
    pub file_num: u32,
    pub data_pos: u32,
    pub num_bytes: u32,
}
impl<'a> Default for GetBlockSliceRequestArgs {
  #[inline]
  fn default() -> Self {
    GetBlockSliceRequestArgs {
      file_num: 0,
      data_pos: 0,
      num_bytes: 0,
    }
  }
}

pub struct GetBlockSliceRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetBlockSliceRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_file_num(&mut self, file_num: u32) {
    self.fbb_.push_slot::<u32>(GetBlockSliceRequest::VT_FILE_NUM, file_num, 0);
  }
  #[inline]
  pub fn add_data_pos(&mut self, data_pos: u32) {
    self.fbb_.push_slot::<u32>(GetBlockSliceRequest::VT_DATA_POS, data_pos, 0);
  }
  #[inline]
  pub fn add_num_bytes(&mut self, num_bytes: u32) {
    self.fbb_.push_slot::<u32>(GetBlockSliceRequest::VT_NUM_BYTES, num_bytes, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetBlockSliceRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetBlockSliceRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetBlockSliceRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetBlockSliceRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetBlockSliceRequest");
      ds.field("file_num", &self.file_num());
      ds.field("data_pos", &self.data_pos());
      ds.field("num_bytes", &self.num_bytes());
      ds.finish()
  }
}
pub enum GetBlockSliceResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetBlockSliceResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetBlockSliceResponse<'a> {
  type Inner = GetBlockSliceResponse<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GetBlockSliceResponse<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetBlockSliceResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetBlockSliceResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<GetBlockSliceResponse<'bldr>> {
    let mut builder = GetBlockSliceResponseBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GetBlockSliceResponse::VT_DATA, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for GetBlockSliceResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct GetBlockSliceResponseArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for GetBlockSliceResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetBlockSliceResponseArgs {
      data: None,
    }
  }
}

pub struct GetBlockSliceResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetBlockSliceResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetBlockSliceResponse::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetBlockSliceResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetBlockSliceResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetBlockSliceResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetBlockSliceResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetBlockSliceResponse");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum GetUndoSliceRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetUndoSliceRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetUndoSliceRequest<'a> {
  type Inner = GetUndoSliceRequest<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GetUndoSliceRequest<'a> {
  pub const VT_FILE_NUM: flatbuffers::VOffsetT = 4;
  pub const VT_UNDO_POS: flatbuffers::VOffsetT = 6;
  pub const VT_NUM_BYTES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetUndoSliceRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetUndoSliceRequestArgs
  ) -> flatbuffers::WIPOffset<GetUndoSliceRequest<'bldr>> {
    let mut builder = GetUndoSliceRequestBuilder::new(_fbb);
    builder.add_num_bytes(args.num_bytes);
    builder.add_undo_pos(args.undo_pos);
    builder.add_file_num(args.file_num);
    builder.finish()
  }


  #[inline]
  pub fn file_num(&self) -> u32 {
    self._tab.get::<u32>(GetUndoSliceRequest::VT_FILE_NUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn undo_pos(&self) -> u32 {
    self._tab.get::<u32>(GetUndoSliceRequest::VT_UNDO_POS, Some(0)).unwrap()
  }
  #[inline]
  pub fn num_bytes(&self) -> u32 {
    self._tab.get::<u32>(GetUndoSliceRequest::VT_NUM_BYTES, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for GetUndoSliceRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("file_num", Self::VT_FILE_NUM, false)?
     .visit_field::<u32>("undo_pos", Self::VT_UNDO_POS, false)?
     .visit_field::<u32>("num_bytes", Self::VT_NUM_BYTES, false)?
     .finish();
    Ok(())
  }
}
pub struct GetUndoSliceRequestArgs {
    pub file_num: u32,
    pub undo_pos: u32,
    pub num_bytes: u32,
}
impl<'a> Default for GetUndoSliceRequestArgs {
  #[inline]
  fn default() -> Self {
    GetUndoSliceRequestArgs {
      file_num: 0,
      undo_pos: 0,
      num_bytes: 0,
    }
  }
}

pub struct GetUndoSliceRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetUndoSliceRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_file_num(&mut self, file_num: u32) {
    self.fbb_.push_slot::<u32>(GetUndoSliceRequest::VT_FILE_NUM, file_num, 0);
  }
  #[inline]
  pub fn add_undo_pos(&mut self, undo_pos: u32) {
    self.fbb_.push_slot::<u32>(GetUndoSliceRequest::VT_UNDO_POS, undo_pos, 0);
  }
  #[inline]
  pub fn add_num_bytes(&mut self, num_bytes: u32) {
    self.fbb_.push_slot::<u32>(GetUndoSliceRequest::VT_NUM_BYTES, num_bytes, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetUndoSliceRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetUndoSliceRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetUndoSliceRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetUndoSliceRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetUndoSliceRequest");
      ds.field("file_num", &self.file_num());
      ds.field("undo_pos", &self.undo_pos());
      ds.field("num_bytes", &self.num_bytes());
      ds.finish()
  }
}
pub enum GetUndoSliceResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetUndoSliceResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetUndoSliceResponse<'a> {
  type Inner = GetUndoSliceResponse<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GetUndoSliceResponse<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetUndoSliceResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetUndoSliceResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<GetUndoSliceResponse<'bldr>> {
    let mut builder = GetUndoSliceResponseBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GetUndoSliceResponse::VT_DATA, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for GetUndoSliceResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct GetUndoSliceResponseArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for GetUndoSliceResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetUndoSliceResponseArgs {
      data: None,
    }
  }
}

pub struct GetUndoSliceResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetUndoSliceResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetUndoSliceResponse::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetUndoSliceResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetUndoSliceResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetUndoSliceResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetUndoSliceResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetUndoSliceResponse");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum GetMempoolRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetMempoolRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetMempoolRequest<'a> {
  type Inner = GetMempoolRequest<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GetMempoolRequest<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetMempoolRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args GetMempoolRequestArgs
  ) -> flatbuffers::WIPOffset<GetMempoolRequest<'bldr>> {
    let mut builder = GetMempoolRequestBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for GetMempoolRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct GetMempoolRequestArgs {
}
impl<'a> Default for GetMempoolRequestArgs {
  #[inline]
  fn default() -> Self {
    GetMempoolRequestArgs {
    }
  }
}

pub struct GetMempoolRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetMempoolRequestBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetMempoolRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetMempoolRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetMempoolRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetMempoolRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetMempoolRequest");
      ds.finish()
  }
}
pub enum GetMempoolResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetMempoolResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetMempoolResponse<'a> {
  type Inner = GetMempoolResponse<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GetMempoolResponse<'a> {
  pub const VT_TXS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetMempoolResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GetMempoolResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<GetMempoolResponse<'bldr>> {
    let mut builder = GetMempoolResponseBuilder::new(_fbb);
    if let Some(x) = args.txs { builder.add_txs(x); }
    builder.finish()
  }


  #[inline]
  pub fn txs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MempoolTx<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MempoolTx>>>>(GetMempoolResponse::VT_TXS, None)
  }
}

impl flatbuffers::Verifiable for GetMempoolResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MempoolTx>>>>("txs", Self::VT_TXS, false)?
     .finish();
    Ok(())
  }
}
pub struct GetMempoolResponseArgs<'a> {
    pub txs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MempoolTx<'a>>>>>,
}
impl<'a> Default for GetMempoolResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetMempoolResponseArgs {
      txs: None,
    }
  }
}

pub struct GetMempoolResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetMempoolResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_txs(&mut self, txs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MempoolTx<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetMempoolResponse::VT_TXS, txs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetMempoolResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetMempoolResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetMempoolResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetMempoolResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetMempoolResponse");
      ds.field("txs", &self.txs());
      ds.finish()
  }
}
}  // pub mod NngInterface
